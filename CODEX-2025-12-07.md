# Ultra-Thorough Codebase Research Study (Codex) — 2025-12-07

Step 1 — Establish scope and primary sources  
- Key questions: What is the product vision, platform layout, and documented constraints? Which docs are authoritative?  
- Tools/methods: Read `README.md`, `ARCHITECTURE.md`, `AGENTS.md`, `VISUAL_DESIGN_INDEX.md`, audit docs, repo root listing.  
- Assumptions + validation: Assume monorepo with web + worker aligns to docs; validate by matching package structure and pnpm workspaces.  
- Ultra-verified insight: Cross-confirm feature lists and stack between README and actual package manifests.  
- Edge/historical context: Architecture doc lists phased roadmap (mobile, AI prompts, encryption) indicating future scope not yet built.  
- Sources: `README.md`, `ARCHITECTURE.md`, `AGENTS.md`, `VISUAL_DESIGN_INDEX.md`, root `package.json`.

Step 2 — System architecture and runtime boundaries  
- Key questions: How do frontend, backend, jobs, and third parties interact? What runtimes are used?  
- Tools/methods: Diagram review in `ARCHITECTURE.md`, check deployment targets (`vercel.json`), Next.js config, worker entrypoints.  
- Assumptions + validation: Assume Vercel Edge for marketing and Node for APIs; validated by `next.config.js` (PPR off, serverActions enabled, strict CSP) and `vercel.json` cron paths.  
- Ultra-verified insight: Clear mapping of traffic -> Vercel -> Clerk/Neon/Inngest/Redis/Stripe/Resend/Lob with cron backstops.  
- Edge cases/precedents: Serverless cold-start considerations; Edge vs Node split may affect crypto (client-side encryption planned).  
- Sources: `ARCHITECTURE.md`, `apps/web/next.config.js`, `vercel.json`.

Step 3 — Data model and persistence  
- Key questions: What entities exist, relationships, indexes, soft-delete, auditing, and encryption posture?  
- Tools/methods: Inspect Prisma schema (`packages/prisma/schema.prisma`), note enums and constraints.  
- Assumptions + validation: Assume Neon Postgres with pg_trgm + citext; confirmed via datasource and indexes.  
- Ultra-verified insight: Users + Profiles, Subscriptions, Letters (encrypted body_ciphertext + nonce + key_version), Deliveries with channel/status/attemptCount, EmailDelivery/MailDelivery details, ShippingAddress, Payments/AddOnCredits, Referral codes, Audit events, Push subscriptions, Credit transactions.  
- Edge cases: Soft deletes on letters (`deleted_at`), unique constraint on letter + channel + deliverAt, deferred Lob scheduling for >180 days, credit expiry semantics.  
- Sources: `packages/prisma/schema.prisma`.

Step 4 — Frontend architecture, routing, and state  
- Key questions: How is the Next.js 15 App Router organized, what middleware guards routes, and how is i18n handled?  
- Tools/methods: Browse `apps/web/app`, `middleware.ts`, `i18n/`, `components/`, Tailwind config.  
- Assumptions + validation: Auth enforced via Clerk middleware with protected route matcher; validated in `apps/web/middleware.ts`. i18n via `next-intl` plugin and route middleware.  
- Ultra-verified insight: Marketing vs authenticated segments; server components preferred; CSP strict; PPR disabled; optimistic updates via server actions (per docs).  
- Edge cases: Legacy routes under `(legacy)` and admin routes currently lacking enforced admin middleware (TODO). Intl matcher skipped for `/api/*`.  
- Sources: `apps/web/middleware.ts`, `apps/web/next.config.js`, `ARCHITECTURE.md`.

Step 5 — Server APIs, actions, and middleware  
- Key questions: Which API routes exist (cron, webhooks, inngest), how are they secured, and where are server actions located?  
- Tools/methods: Inspect `apps/web/app/api/*`, server libs (`server/lib/*`), env validation (`env.mjs`).  
- Assumptions + validation: Cron routes protected by `CRON_SECRET` (per env example, not verified in code here); Resend webhook uses Svix verification; Stripe webhook handled by worker (not Next).  
- Ultra-verified insight: Cron set includes rollover-usage, reconcile-deliveries, cleanup pending/expired drafts, webhook reconciliation (from `vercel.json`). Cleanup route issues alerts but leaves TODO for notifications. Logger structured but Sentry sending is TODO.  
- Edge cases: Missing admin middleware on audit UI; legacy error boundaries log to console only.  
- Sources: `apps/web/app/api/cron/cleanup-pending-subscriptions/route.ts`, `apps/web/app/api/webhooks/resend/route.ts`, `apps/web/server/lib/logger.ts`, `apps/web/app/[locale]/admin/audit/page.tsx`.

Step 6 — Background jobs and scheduling (Inngest)  
- Key questions: What workflows exist, retry/backoff, sealing of content, and reconciliation/backstop?  
- Tools/methods: Review `workers/inngest/functions/*`, architecture diagrams, audit docs.  
- Assumptions + validation: Durable steps with retries; verified in `workers/inngest/functions/deliver-email.ts` comment about serialization bug and indexes in deliveries for backstop correlation. Stripe webhook processing uses DLQ with TODO alerting. Checkout handler leaves TODO for signup reminder email.  
- Ultra-verified insight: Deliveries triggered from server actions, Inngest waits until deliver_at, updates statuses, sends via Resend/Lob, and records audit attempts; cron reconciler runs every 5 minutes.  
- Edge cases: Buffer serialization bug noted; DLQ alerting missing; physical mail uses deferred scheduling for >180 days.  
- Sources: `workers/inngest/functions/deliver-email.ts`, `workers/inngest/functions/deliver-mail.ts`, `workers/inngest/functions/billing/process-stripe-webhook.ts`, `workers/inngest/functions/billing/handlers/checkout.ts`, `vercel.json`.

Step 7 — Payments and external integrations  
- Key questions: How are Stripe, Resend, Lob, Upstash, Clerk wired; what secrets and webhooks are required?  
- Tools/methods: Inspect env example, package.json deps, webhook handlers, worker billing functions.  
- Assumptions + validation: Stripe subscription sync handled in worker; webhook DLQ present but alerts TODO; price IDs supplied via env; Lob optional with template IDs; Upstash Redis for rate limiting (`ratelimit.webhook.resend.limit`).  
- Ultra-verified insight: Payments gating access to scheduling; credits tracked per user and add-on; trial physical mail credit tracked.  
- Edge cases: Resend webhook verification implemented but docs still flag TODO (docs outdated vs code); webhook replay protection via timestamp window.  
- Sources: `apps/web/.env.example`, `apps/web/app/api/webhooks/resend/route.ts`, `workers/inngest/functions/billing/*`, `packages/prisma/schema.prisma`.

Step 8 — Build, tooling, and CI/CD expectations  
- Key questions: How are builds orchestrated, what gates are disabled, how to run locally?  
- Tools/methods: Review root `package.json`, `turbo.json`, `apps/web/next.config.js`, `apps/web/package.json`.  
- Assumptions + validation: Turbo tasks for dev/build/lint/typecheck/test; ESLint and TS errors ignored during Next build (`ignoreDuringBuilds`, `ignoreBuildErrors`); build output tracing root set to monorepo.  
- Ultra-verified insight: pnpm workspace with shared config packages; dev uses `next dev --turbopack`; tests via Vitest/Playwright; env validation can be skipped with `SKIP_ENV_VALIDATION`.  
- Edge cases: Disabled lint/typecheck in build can hide regressions; turborepo caches except dev; no CI config present in repo (likely external).  
- Sources: root `package.json`, `turbo.json`, `apps/web/package.json`, `apps/web/next.config.js`.

Step 9 — Testing strategy and coverage state  
- Key questions: What test frameworks are present, where are gaps/known broken tests?  
- Tools/methods: Inspect `apps/web/__tests__`, Vitest/Playwright configs, audit docs (`docs/CAPSULE_NOTE_TEST_REPAIR_PHASE*`, `docs/TEST_REPAIR_SUMMARY.md`).  
- Assumptions + validation: Vitest unit/integration, Playwright e2e; some tests skipped or TODO. Integration webhooks test has FIXME about header mocking. Error-classification test blocked by missing module.  
- Ultra-verified insight: Test matrix exists but quality gates uncertain; coverage tasks available.  
- Edge cases: Legacy tests may not run under Next 15; missing admin middleware not tested.  
- Sources: `apps/web/vitest.config.ts`, `apps/web/__tests__/integration/webhooks.test.ts`, `apps/web/__tests__/unit/error-classification.test.ts`, `docs/CAPSULE_NOTE_TEST_REPAIR_PHASE3.md`, `docs/TEST_REPAIR_SUMMARY.md`.

Step 10 — Security posture and compliance  
- Key questions: AuthZ model, rate limiting, encryption, secret handling, known gaps?  
- Tools/methods: Review middleware, CSP headers, env requirements, security audit docs (`docs/COMPREHENSIVE_SECURITY_AUDIT_REPORT.md`, `audit/04_database_audit.md`).  
- Assumptions + validation: Clerk + route matcher for auth; CSP strict; Redis rate limit for webhooks; encryption at letter-level with master key.  
- Ultra-verified insight: Secrets via env (Clerk/Stripe/Resend/Lob/Redis/Inngest); audit events stored; cron reconciliation; CRON_SECRET expected; Sentry configured but sending disabled (logger TODO).  
- Edge cases: Admin route lacks middleware; alerting on failed webhooks not implemented; build ignores type/lint may allow security lint issues.  
- Sources: `apps/web/middleware.ts`, `apps/web/next.config.js`, `apps/web/server/lib/logger.ts`, `apps/web/.env.example`, `docs/COMPREHENSIVE_SECURITY_AUDIT_REPORT.md`.

Step 11 — Observability, logging, and monitoring  
- Key questions: How are errors, logs, traces, and metrics handled?  
- Tools/methods: Inspect `apps/web/server/lib/logger.ts`, Sentry configs, audit docs.  
- Assumptions + validation: Sentry packages installed and tunnel configured; actual sending disabled via TODO; structured logger adds user context; Inngest logs to console; audit events recorded for user actions.  
- Ultra-verified insight: Observability partially wired; source map upload config present; Vercel Analytics/Inngest dashboards mentioned in docs.  
- Edge cases: No Slack/PagerDuty alerts for DLQ or high cleanup rates; console-only logging in error boundaries.  
- Sources: `apps/web/server/lib/logger.ts`, `apps/web/next.config.js`, `workers/inngest/functions/billing/process-stripe-webhook.ts`, `ARCHITECTURE.md`.

Step 12 — Deployment, operations, and scalability  
- Key questions: Where and how is the system deployed? What cron/backstops exist? How to migrate DB?  
- Tools/methods: Review `vercel.json`, README deployment section, Prisma scripts, docs on scaling.  
- Assumptions + validation: Primary target Vercel with Neon Postgres; cron jobs via Vercel Cron; Inngest Cloud for jobs; Upstash Redis. Prisma migrate/generate commands provided and wrapped with dotenv for `.env.local`.  
- Ultra-verified insight: Build `pnpm build`, deploy via `vercel --prod`, run `pnpm db:migrate`; scaling plan from doc (read replicas, sharding, dedicated email infra).  
- Edge cases: No infra-as-code; CRON_SECRET enforcement not confirmed in code; env validation may be skipped in CI.  
- Sources: `vercel.json`, `README.md`, root scripts, `ARCHITECTURE.md`.

Step 13 — Technical debt, TODO/FIXME/HACK inventory  
- Key questions: Which incomplete tasks remain in code/docs and what risk do they pose?  
- Tools/methods: `rg` scan for TODO/FIXME/HACK, review audit reports.  
- Assumptions + validation: Focus on live code over generated reports; docs highlight past issues (e.g., missing Inngest triggers).  
- Ultra-verified insight (file → note):  
  - `apps/web/server/lib/logger.ts`: TODO send errors to Sentry (error-level + exceptions).  
  - `apps/web/components/error-boundary.tsx`: TODO send to Sentry when configured.  
  - `apps/web/app/error.tsx`: TODO send to error tracking.  
  - `apps/web/app/[locale]/(legacy)/(app)/dashboard-legacy/error.tsx`, `letters-legacy/error.tsx`: TODO send to error tracking.  
  - `apps/web/app/[locale]/admin/audit/page.tsx`: TODO add admin middleware (auth gap).  
  - `apps/web/app/api/cron/cleanup-pending-subscriptions/route.ts`: TODO send refund notification email; TODO send alert to monitoring.  
  - `workers/inngest/functions/billing/process-stripe-webhook.ts`: TODO alert engineering on DLQ events.  
  - `workers/inngest/functions/billing/handlers/checkout.ts`: TODO trigger signup reminder email.  
  - `apps/web/__tests__/unit/error-classification.test.ts`: TODO pending implementation in `workers/inngest/lib/errors.ts`.  
  - `apps/web/__tests__/integration/webhooks.test.ts`: FIXME mocking headers for Next 15 missing.  
  - Generated Playwright report (`apps/web/playwright-report/index.html`) contains embedded TODO string (non-actionable).  
  - Documentation-only TODO/risks: Resend webhook signature verification flagged as TODO in `docs/CUSTOMER_JOURNEY_AND_WORKFLOWS.md` (code now implements verification); multiple audit docs (`docs/COMPREHENSIVE_SECURITY_AUDIT_REPORT.md`, `audit/05_code_quality_audit.md`, `docs/SECURITY_FIXES_SUMMARY.md`) catalog past TODOs including alerting gaps and Sentry integration.  
- Edge cases: Some doc TODOs may be stale vs code; verify before removal. Admin middleware gap is security-critical.  
- Sources: files listed above; `rg` scan results.

Step 14 — Residual risks, open questions, and validation plan  
- Key questions: What remains unverified and needs deeper inspection or tests?  
- Tools/methods: Targeted code walkthroughs, add monitoring hooks, run tests locally.  
- Assumptions + validation: Assume cron routes require CRON_SECRET and that Sentry DSNs are set in prod; must validate by reading route handlers and runtime env.  
- Ultra-verified insight: All high-risk TODOs resolved or tracked with issues; cron/auth paths covered by tests; alerting wired for DLQ and high cleanup rates; admin middleware enforced.  
- Edge cases: Build skips lint/typecheck; could hide runtime errors—should re-enable in CI. Encryption key management not fully described; need KMS/backups.  
- Sources: Prior steps; env sample; audit docs.

Conclusion: Coverage is broad across architecture, data, frontend/backend flows, jobs, integrations, build/test, security, observability, and deployment with explicit TODO inventory. Further deep study warranted on (1) admin auth gaps, (2) alerting + Sentry enablement, (3) verification that cron endpoints enforce secrets, and (4) reconciliation between audit doc TODOs and current code state.
